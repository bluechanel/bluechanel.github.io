---
title: 🧬 LangGraph入门指南：从基础ChatBot到多智能体实战
description: 这是一篇LangGraph终极入门指南，从核心概念、工具调用、记忆管理，到高级的多智能体协作与实战项目，带你全面掌握新一代AI Agent开发框架。LangGraph, LangGraph教程, LangGraph指南, AI Agent框架
date: 2025-09-04
updateDate: 2025-09-04
tags: ["MCP","LangGraph","AI","LLM","RAG","LangChain","Vector Store"]
cover: cover/264605ee-e889-806e-b847-ce4e7bcba614_bfae1b095036992e55b3c221e6c93543.png
---

# LangGraph介绍


## LangGraph的诞生


LangGraph由LangChain团队开发。而**LangChain** 诞生于 **2022 年 10 月**，最初只是一个帮助开发者调用大语言模型（LLM）的工具包。它的定位是“链式调用”，用 **Chain**（链）把 Prompt、模型、工具（Tool）、数据源等连接在一起。凭借这个简单而强大的抽象，LangChain 很快成为当时最受欢迎的 LLM 应用框架。


早期的LangChain有很多自定义的Chain，很方便做demo。但是由于其过度封装，工程化的时候遇到了很多的麻烦，一旦想自定义就得继承原有Chian，然后再在**from_llm**中编写逻辑，写了很多不必要的代码。（曾经为了修改Chain，想debug学习一下代码，但是一路下去，不知道跳转到哪里去了，当时还有LangChain和LlamaIndex之争。）


```python
from langchain import hub
from langchain.chains import RetrievalQA

# See full prompt at https://smith.langchain.com/hub/rlm/rag-prompt
prompt = hub.pull("rlm/rag-prompt")

qa_chain = RetrievalQA.from_llm(
    llm, retriever=vectorstore.as_retriever(), prompt=prompt
)

qa_chain("What are autonomous agents?")
```


后来在2023年8月推出了LCEL，Chain的调用才变得直观起来。


```python
from langchain import hub
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough

prompt = hub.pull("rlm/rag-prompt")

def format_docs(docs):
    return "\n\n".join(doc.page_content for doc in docs)

qa_chain = (
    {
        "context": vectorstore.as_retriever() | format_docs,
        "question": RunnablePassthrough(),
    }
    | prompt
    | llm
    | StrOutputParser()
)

qa_chain.invoke("What are autonomous agents?")
```

- 但随着应用越来越复杂，**线性链式**结构逐渐暴露很多局限，在实际开发时很痛苦：
    - 一旦有逻辑分支就会变得冗长。
    - 难以表示循环、状态保持。
    - 多智能体之间的消息传递无法自然表达。

于是，LangChain 团队推出了新的尝试 —— **LangGraph，**于2024年1月推出0.0.1版本。


## LangGraph的特点

- **LangChain** 用“链”描述逻辑，适合 **简单的、一次性的 LLM 调用**。
- **LangGraph** 用“图”描述逻辑，适合 **复杂的、有状态的、多轮或多智能体协作**。

**LangGraph** 更像“流程编排系统”。利用了图的思想：节点、边与状态其核心抽象是 **图（Graph）**：

- **节点（Node）**：执行单元，可以是调用一个模型、运行一个工具、访问一个数据库，或者一个人工审批环节，自由的编写代码。
- **边（Edge）**：控制数据流，决定从一个节点走向另一个节点，可以是顺序执行、条件分支、循环。
- **状态（State）**：全局上下文，贯穿整个图的执行过程。它可以被节点读写，从而支持有状态的对话、多轮任务执行，甚至长时任务恢复（其实就是一个字典）。

于是LangGraph 相较于传 LangChain有了以下优势：

- **有状态执行**： 支持跨节点共享上下文，能够保存和恢复任务，使Agent的上下文管理变得简单。
- **灵活的流程表达**： 分支、循环、人机协同都可以通过图结构自然表达。
- **直观的运行逻辑**：
使用LangSmith或者`graph.get_graph(xray=True).draw_mermaid_png()`可以轻松的查看图的整体结构和运行逻辑关系，方便追踪执行路径、调试 agent、持久存储执行状态。
- **更低层的可控性**：
LangGraph 真正做到了框架，让开发者完全掌控 agent 的运行逻辑，专心编写业务代码。

## 与Dify等低代码有何不同


**LangGraph** 与 **Dify**这类平台比较，定位有明显不同：

- **LangGraph**：
    - 开源框架，更偏向 **开发者**。
    - 提供底层抽象，让你可以搭建高度自定义的 agent 工作流。
    - 更适合需要**灵活控制**、**多智能体协作**的复杂应用。
- **Dify**：
    - 属于 **AI 应用开发中台**。
    - 提供的是“**低代码**”环境，开发者通过界面化配置快速构建应用。
    - 优点是上手快、集成好，但灵活性受限。

LangGraph的唯一缺点就是不能直接给非技术人员使用。因此实际开发中，很多时候用Dify，Coze等快速验证想法，再使用LangGraph重新开发，优化各部分算法，提高运行效率。


# LangGraph实战


这里我将实战分为了6个部分，从一个简单的聊天机器人，到一个能够进行自主研究的复杂系统，LangGraph是通往更强大AI应用的大门。


## 基于LangGraph开发一个聊天bot


目前的AI应用，无论是什么领域，其交互方式都是对话。所以学习LangGraph最理想的起点，就是构建一个基础的聊天机器人。帮助我们快速理解“状态图”（StateGraph）是如何定义、节点是如何工作，以及数据（如对话历史）是如何在状态中流转的。


通过一个简单的实例，掌握LangGraph最核心的工作流程：定义状态 -> 添加节点 -> 连接边 -> 编译图 -> 执行。这是后续所有复杂应用的基础。

> 完整教程：[LangGraph教程(一)：从零开始构建你的第一个AI聊天机器人](https://www.wileyzhang.com/posts/264605ee-e889-8089-81f9-d9bc9bb64ee8) 

## 在LangGraph中调用工具


Agent的其中定义就是能够自主使用工具外部世界互动，而不仅仅是依赖模型内部的知识。工具调用(function_call)是实现这一目标的核心。它让Agent能够查询实时信息、调用API、访问数据库，从而解决实际问题。


LangGraph极大地简化了工具调用的流程。它不仅内置了处理工具选择、执行和结果返回的`ToolNode`，还提供了强大的条件路由`tools_condition`来判断模型是应该继续回答还是调用工具。同时LangGraph还支持使用MCP服务。

> 完整教程：[LangGraph教程(二)：掌握Agent核心能力-工具调用（自定义、预构建与MCP）](https://www.wileyzhang.com/posts/264605ee-e889-80b3-a6c6-e66d154e6f95) 

## 在LangGraph中添加记忆


长短期记忆也是Agent中的一个定义，如果Agent每次交互都是一次“全新的开始”，那它将无法处理有上下文的连续任务。而记忆机制是Agent保持状态、记住历史的能力，这对于多轮对话、长任务执行和个性化服务至关重要。


LangGraph提供了强大的检查点（Checkpointing）机制来保存和恢复图的执行状态。探讨两种核心的记忆模式：**任务级记忆**，通过内存或Redis等后端实现单个任务的断点续执；以及**用户级记忆**，通过集成Mem0这类智能记忆层，实现跨会话的、长期的用户偏好和知识沉淀。

> 完整教程：[LangGraph教程(三)：为你的Agent添加记忆（Checkpoint持久化与Mem0）](https://www.wileyzhang.com/posts/264605ee-e889-808d-aa04-e8fe07bc9ec7) 

## 在LangGraph中实现人机交互


在许多关键场景，如金融交易确认、医疗诊断辅助或高风险操作中，人的监督和决策是不可或缺的。Human-in-the-loop（人机协同）正是为了解决这个问题。


LangGraph通过其内在的“中断”机制，优雅地实现了人机交互。当Agent遇到不确定性或需要人工审批时，它可以主动“暂停”执行，将控制权交还给人类。待人类用户提供输入或确认后，Agent又能从中断处无缝地继续执行。

> 完整教程：[LangGraph教程(四)：实现人机协同（Human-in-the-loop）的关键技巧](https://www.wileyzhang.com/posts/264605ee-e889-80f8-a8ce-e89efa0548c5) 

## 多智能体与LangGraph子图


同人类社会的分工一样，当任务变得异常复杂，需要多个不同领域的专业知识时，单独Agent往往不能解决复杂问题。“分工协作”是提升效率和准确率的关键。多智能体（Multi-Agent）系统应运而生。


LangGraph通过**子图 (Subgraph)** 和**主管 (Supervisor)** 架构，为构建复杂的多智能体协作系统提供了解决方案。可以将不同的Agent封装成独立的子图，然后由一个“主管”Agent来负责任务的分解和调度。亲手实现一个“主管-助理”式的协作流程。

> 完整教程：[LangGraph进阶：构建多智能体协作系统（Supervisor架构与子图实战）](https://www.wileyzhang.com/posts/264605ee-e889-806a-93a7-e8acc33707b6) 

## LangGraph实现DeepResearch


现在各家AI都有一个“深度研究”功能，在掌握了LangGraph的能力后，我们使用LangGraph来复现它。


项目模仿了人类专家的研究过程：自主地生成搜索查询、执行网络研究、对结果进行“反思”和“批判”，并迭代地优化信息，直到生成一份全面、有深度、带引用的研究报告。


这个项目将前面学到的所有知识点——工具调用、状态管理、条件路由、多轮循环——完美地融合在一起。

> 完整教程：[LangGraph实战项目：从零复现DeepResearch自动化研究代理](https://www.wileyzhang.com/posts/264605ee-e889-801d-b602-c19241482cca) 

# 最后


这一系列文章被我命名为 **《LangGraph 入门全解》**，到这里已全部写完。如果你对 LangGraph 或 AI Agent 有更多兴趣，欢迎在评论区留言与我交流。

